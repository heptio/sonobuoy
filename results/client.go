package results

import (
	"archive/tar"
	"compress/gzip"
	"encoding/json"
	"errors"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/heptio/sonobuoy/pkg/config"
	"github.com/heptio/sonobuoy/pkg/discovery"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/version"
)

const (
	// Defaults for current version

	HostsDir                  = "hosts/"
	NamespacedResourcesDir    = "resources/ns/"
	NonNamespacedResourcesDir = "resources/cluster/"
	PluginsDir                = "plugins/"
	PodLogs                   = "podlogs/"
	MetadataDir               = "meta/"

	ServicesFile      = "Services.json"
	NodesFile         = "Nodes.json"
	ServerVersionFile = "serverversion.json"
	ServerGroupsFile  = "servergroups.json"
)

const (
	// UnknownVersion lets the consumer know if this client can detect the archive version or not.
	UnknownVersion = "v?.?"
	VersionEight   = "v0.8"
	VersionNine    = "v0.9"
	VersionTen     = "v0.10"
)

// Archive holds an io.ReadCloser that can read through the archive once.
// Create many of these for concurrent reading.
type Archive struct {
	io.ReadCloser
	// Version is the version of the archive being inspected.
	Version string
}

// OpenArchive will open the archive, detect the version and return a new
// archive. The file is expected to be a file generated by Sonobuoy.
// Caller is responsible for closing.
func OpenArchive(filename string) (*Archive, error) {
	r, err := OpenArchiveWithVersion(filename, UnknownVersion)
	if err != nil {
		return nil, err
	}
	defer r.Close()
	metadata := r.Metadata()
	var version string
	if strings.HasPrefix(metadata.Config.Version, VersionEight) {
		version = VersionEight
	} else if strings.HasPrefix(metadata.Config.Version, VersionNine) {
		version = VersionNine
	} else if strings.HasPrefix(metadata.Config.Version, VersionTen) {
		version = VersionTen
	} else {
		return nil, errors.New("cannot discover Sonobuoy archive version")
	}
	return OpenArchiveWithVersion(filename, version)
}

// OpenArchiveWithVersion opens the archive file and sets the version on the
// archive struct.
func OpenArchiveWithVersion(filename, version string) (*Archive, error) {
	// TODO(chuckha) ensure we support the passed in version
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	zr, err := gzip.NewReader(f)
	if err != nil {
		return nil, err
	}
	return &Archive{zr, version}, nil
}

// tarFileInfo implements os.FileInfo and extends the Sys() method to
// return a reader to a file in a tar archive.
type tarFileInfo struct {
	os.FileInfo
	io.Reader
}

// Sys is going to be an io.Reader to a file in a tar archive.
// This is how data is extracted from the archive.
func (t *tarFileInfo) Sys() interface{} {
	return t.Reader
}

// WalkFilesWithPrefix will go through every file in the archive and
// run the walkfn on any file that matches the prefix passed in.
func (r *Archive) WalkFilesWithPrefix(prefix string, walkfn filepath.WalkFunc) error {
	tr := tar.NewReader(r)
	var err error
	var header *tar.Header
	for {
		header, err = tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		if strings.HasPrefix(filepath.Clean(header.Name), prefix) {
			info := &tarFileInfo{
				header.FileInfo(),
				tr,
			}
			err = walkfn(filepath.Clean(header.Name), info, err)
		}
	}
	return nil
}

// NamespacedResources iterates and executes walkfn for every namespaced resource file.
func (r *Archive) NamespacedResources(walkfn filepath.WalkFunc) error {
	return r.WalkFilesWithPrefix(NamespacedResourcesDir, walkfn)
}

// NonNamespacedResources iterates and executes walkfn for every non-namespaced resource file.
func (r *Archive) NonNamespacedResources(walkfn filepath.WalkFunc) error {
	return r.WalkFilesWithPrefix(nonNamespacedResources(r.Version), walkfn)
}

// Hosts iterates and executes walkfn for all files relating to the host data.
func (r *Archive) Hosts(walkfn filepath.WalkFunc) error {
	return r.WalkFilesWithPrefix(HostsDir, walkfn)
}

// Plugins walks each plugin file executing walkfn on each.
func (r *Archive) Plugins(walkfn filepath.WalkFunc) error {
	return r.WalkFilesWithPrefix(PluginsDir, walkfn)
}

// PodLogs walks each pod log file executing walkfn on each.
func (r *Archive) PodLogs(walkfn filepath.WalkFunc) error {
	return r.WalkFilesWithPrefix(PodLogs, walkfn)
}

// Metadata extracts the information about the Sonobuoy run itself.
// This method does not depend on `r.Version` because this is the method used
// to discover the version of the archive.
func (r *Archive) Metadata() *Metadata {
	out := &Metadata{
		Config:    config.Config{},
		QueryData: make([]discovery.QueryData, 0),
	}

	r.WalkFilesWithPrefix("", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if path == configFile(VersionTen) || path == configFile(VersionEight) {
			reader, ok := info.Sys().(io.Reader)
			if !ok {
				return errors.New("info.Sys() is not a reader")
			}
			decoder := json.NewDecoder(reader)
			err := decoder.Decode(&out.Config)
			if err != nil {
				return err
			}
		}
		if path == queryDataFile(VersionTen) || path == queryDataFile(VersionEight) {
			reader, ok := info.Sys().(io.Reader)
			if !ok {
				return errors.New("info.Sys() is not a reader")
			}
			decoder := json.NewDecoder(reader)
			err := decoder.Decode(&out.QueryData)
			if err != nil {
				return err
			}
		}
		return nil
	})
	return out
}

// ServerVersion extracts cluster version information from the Sonobuoy result.
func (r *Archive) ServerVersion() *version.Info {
	v := &version.Info{}
	r.WalkFilesWithPrefix(serverVersionFile(r.Version), func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		reader, ok := info.Sys().(io.Reader)
		if !ok {
			return errors.New("info.Sys() is not a reader")
		}
		decoder := json.NewDecoder(reader)
		err = decoder.Decode(v)
		if err != nil {
			return err
		}
		return nil
	})
	return v
}

// ServerGroups extracts the available APIs to the cluster in the Sonobuoy result.
func (r *Archive) ServerGroups() *metav1.APIGroupList {
	groups := &metav1.APIGroupList{}
	r.WalkFilesWithPrefix(ServerGroupsFile, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		reader, ok := info.Sys().(io.Reader)
		if !ok {
			return errors.New("info.Sys() is not a reader")
		}
		decoder := json.NewDecoder(reader)
		err = decoder.Decode(groups)
		if err != nil {
			return err
		}
		return nil
	})
	return groups
}

// Functions for helping with backwards compatibility

func serverVersionFile(version string) string {
	switch version {
	case VersionEight:
		return "serverversion/serverversion.json"
	default:
		return "serverversion.json"
	}
}

func queryDataFile(version string) string {
	switch version {
	case VersionEight:
		return "resources/non-ns/results.json"
	default:
		return "meta/query-time.json"
	}
}

func configFile(version string) string {
	switch version {
	case VersionEight:
		return "config.json"
	default:
		return "meta/config.json"
	}
}

func nonNamespacedResources(version string) string {
	switch version {
	case VersionEight:
		return "resources/non-ns/"
	default:
		return NonNamespacedResourcesDir
	}
}
